# komondor

[![NPM version][npm-image]][npm-url]
[![NPM downloads][downloads-image]][downloads-url]
[![Build status][travis-image]][travis-url]
[![Coverage Status][coveralls-image]][coveralls-url]

[![Greenkeeper][greenkeeper-image]][greenkeeper-url]
[![Semantic Release][semantic-release-image]][semantic-release-url]

[![Visual Studio Code][vscode-image]][vscode-url]
[![Wallaby.js][wallaby-image]][wallaby-url]

`komondor` is your friendly guard dog to write tests across boundaries.

## The Problem

Boundary is where two systems meet and communicate with each other using data structures and primitive types.

For example, making calls to remote server or component written by another team in another language.

When we write tests that needs to communicate across the boundary,
we often need to create a test double to similate the behavior we need in our tests.

This allow us to write tests that are fast to run and also decouple from the remote system,
so that we don't have to configure the remote system to produce the expected behavior.

However, if we only have these tests,
we will not be able to catch breakage when the remote system changes its behavior.

Traditionally, we will have a suite of system integration test to make sure the system is working as a whole.
However, these tests are hard to configure and slow.
Most of the time we can only create or run a handful of these tests to make sure all or part of the critical paths are covered.

When the behavior of the other system is changed,
you have to go through some manual process to make actual calls,
adjust the test doubles you have, and fix the code.

That's a lot of manual work and the worst of all is that it reduce the level of trust you have on your test suite.

## The solution

`komondor` can turn your stubbed unit test to system integration test by a simple switch.
It also makes writing of these tests systematic and simple.

When writing a test that needs to access a remote system across a boundary,
you will do a three steps test-waltz:

- write a test and making it pass while making actual remote calls
- find out and record the data you recevied from the remote calls
- use these data to create a test double and use the test doubl in the test

Using `komondor`, these three steps becomes very straight forward.

The following example will create a test that needs to communicate to GitHub api.

### step 1: writing a passing test with actual remote calls

```ts
import { test } from 'ava'
import { spec } from 'komondor'

// test subject
function getFollowers(github: GitHub, username: string) {
  return new Promise((a, r) => {
    github.users.getFollowersForUser({
      username
    }, (err, res) => {
      if (err) r(err)
      a(res)
    })
  })
}

test('get follower of a user', t => {
    const github = new GitHub()
})


## spec(fn, options): Promise<Spec<T>>

To write test for a service boundary,
you will do a test waltz:

- create a test that makes real calls
- save the call result
- replay the call result

## Todo

- Complete README
- Add global config
- Add scenario

## Contribute

```sh
# right after fork
npm install

# begin making changes
git checkout -b <branch>
npm run watch

# edit `webpack.config.dev.js` to exclude dependencies for the global build.

# after making change(s)
git commit -m "<commit message>"
git push

# create PR
```

## Npm Commands

There are a few useful commands you can use during development.

```sh
# Run tests (and lint) automatically whenever you save a file.
npm run watch

# Run tests with coverage stats (but won't fail you if coverage does not meet criteria)
npm run test

# Manually verify the project.
# This will be ran during 'npm preversion' so you normally don't need to run this yourself.
npm run verify

# Build the project.
# You normally don't need to do this.
npm run build

# Run tslint
# You normally don't need to do this as `npm run watch` and `npm version` will automatically run lint for you.
npm run lint
```

Generated by `generator-unional@0.0.1`

[npm-image]: https://img.shields.io/npm/v/komondor.svg?style=flat
[npm-url]: https://npmjs.org/package/komondor
[downloads-image]: https://img.shields.io/npm/dm/komondor.svg?style=flat
[downloads-url]: https://npmjs.org/package/komondor
[travis-image]: https://img.shields.io/travis/unional/komondor/master.svg?style=flat
[travis-url]: https://travis-ci.org/unional/komondor?branch=master
[coveralls-image]: https://coveralls.io/repos/github/unional/komondor/badge.svg
[coveralls-url]: https://coveralls.io/github/unional/komondor
[badge-size-es5-url]: http://img.badgesize.io/unional/komondor/master/dist/komondor.es5.js.svg?label=es5_size
[greenkeeper-image]:https://badges.greenkeeper.io/unional/komondor.svg
[greenkeeper-url]:https://greenkeeper.io/
[semantic-release-image]:https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg
[semantic-release-url]:https://github.com/semantic-release/semantic-release
[wallaby-image]:https://img.shields.io/badge/wallaby.js-configured-green.svg
[wallaby-url]:https://wallabyjs.com
[vscode-image]:https://img.shields.io/badge/vscode-ready-green.svg
[vscode-url]:https://code.visualstudio.com/
